#!/usr/bin/env python
# Copyright (C) 2011 Gregor Richards
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import os
import shutil
import subprocess
import sys

# the command to run
cmd = []

# the mount points
mounts = {}

class Mount:
    def __init__(self, rrw, host, guest):
        self.rrw = rrw
        self.host = host
        self.guest = guest

# the basic, predefined mounts
def baseMounts():
    for m in ["/usr", "/bin", "/lib", "/lib32", "/lib64", "/etc/alternatives", "/dev"]:
        if os.path.isdir(m):
            mounts[m] = Mount("r", m, m)

# child's cwd
cwd = os.getcwd()

# (optional) timeout
timeout = 0

# (optional) memory
memory = "256M"

def usage():
    print("Use: umlbox [options] <command>\n" +
          "Options:\n" +
          "\t-B: Use base set of mount points.\n" +
          "\t-f[w] <dir>: Share the given directory, optionally writable.\n" +
          "\t-t[w] <guest dir> <host dir>: Share the given directory with a different name, optionally writable.\n" +
          "\t--cwd <dir>: Set cwd in guest to <dir>.\n" +
          "\t--no-cwd: Set cwd in guest to /.\n" +
          "\t--copy-cwd: Copy the host cwd (the default).\n" +
          "\t-T <timeout>: Set a timeout.\n" +
          "\t-m <memory>: Set the memory limit (default 256M).\n")

i = 1
oncmd = False
while i < len(sys.argv):
    arg = sys.argv[i]
    if oncmd or arg[0] != "-":
        oncmd = True
        cmd.append("'" + arg.replace("'", "'\\\''") + "'")

    elif arg == "-B" or arg == "--base-mounts":
        baseMounts()

    elif arg == "-f" or arg == "--mount":
        i += 1
        mdir = os.path.abspath(sys.argv[i])
        mounts[mdir] = Mount("r", mdir, mdir)

    elif arg == "-fw" or arg == "--mount-write":
        i += 1
        mdir = os.path.abspath(sys.argv[i])
        mounts[mdir] = Mount("rw", mdir, mdir)

    elif arg == "-t" or arg == "--translate":
        i += 1
        guest = sys.argv[i]
        i += 1
        host = os.path.abspath(sys.argv[i])
        mounts[guest] = Mount("r", host, guest)

    elif arg == "-tw" or arg == "--translate-write":
        i += 1
        guest = sys.argv[i]
        i += 1
        host = os.path.abspath(sys.argv[i])
        mounts[guest] = Mount("rw", host, guest)

    elif arg == "--cwd":
        i += 1
        cwd = sys.argv[i]

    elif arg == "--no-cwd":
        cwd = "/"

    elif arg == "--copy-cwd":
        cwd = os.getcwd()

    elif arg == "-T" or arg == "--timeout":
        i += 1
        timeout = int(sys.argv[i])

    elif arg == "-m" or arg == "-M":
        i += 1
        memory = sys.argv[i]

    else:
        usage()
        sys.exit(1)

    i += 1

if len(cmd) == 0:
    usage()
    sys.exit(1)

# globals
linux = os.path.dirname(sys.argv[0]) + "/umlbox-linux"
pid = str(os.getpid())
conf = "/tmp/" + pid + ".conf"

# figure out the hostmount configuration
mountPaths = mounts.keys()
mountPaths.sort(lambda x,y: cmp(len(x), len(y)))

# and make the hostmount commands
hostmounts = ""
for path in mountPaths:
    mount = mounts[path]
    hostmounts += "hostmount " + mount.rrw + " " + mount.host + " " + mount.guest + "\n"

# Make the configuration file
conff = open(conf, "w")
conff.write(hostmounts +
            "mount tmpfs /tmp tmpfs\n" +
            "mount proc /proc proc\n" +
            "mount sysfs /sys sysfs\n" +
            "timeout " + str(timeout) + "\n" +
            "run " + cwd + " " + " ".join(cmd) + "\n")
conff.close()

os.dup2(1, 3) # To keep output
os.dup2(1, 4)
devnullr = os.open("/dev/null", os.O_RDONLY)
devnullw = os.open("/dev/null", os.O_WRONLY)

subprocess.call([linux, "ubda=" + conf, "mem=" + memory, "con1=fd:0,fd:3", "con=null,null"], stdout=devnullw, stderr=devnullw)
os.close(devnullr)
os.close(devnullw)
os.close(3)

os.unlink(conf)
